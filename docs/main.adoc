= Celestial
Ronen Narkis, <narkisr@gmail.com> v0.11.0
:toc: left
:!numbered:
:idseparator: -
:idprefix:
:source-highlighter: pygments
:pygments-style: friendly
:sectlinks:
:ubuntuversion: 14.x
:redisversion: 2.x
:celestialversion: 0.11.0
:javaversion: 1.7.x
:imagesdir: docs/img

== Introduction 

Celestial is a server that enables to manage machines life cycle from initial VM creation to deployment automation and user access control,

== Setup

Celestial was designed with deployment simplicity in mind, only two services are required to run Celestial itself and a [Redis](http://redis.io/) instance,

Perquisites:

*   Ubuntu {ubuntuversion}
*   Java {javaversion}
*   Redis >= {redisversion} and up

The following options are available to get started quickly:

* Use Celestial install script.
* Setup a local vagrant machine.

There are a couple of options to get Celestial going, using a dedicate Ubuntu VM and the install script is the recommended production option.

=== Install script

The following install script sets up a clean celestial installation on an Ubuntu server (ubuntuversion) instance:

```bash
$ wget https://gist.githubusercontent.com/narkisr/ad24502f7a4035391692/raw/celestial-install.sh 
$ sudo ./celestial-install.sh
```

Once its done running you have a celestial instance ready and running now:

* Point your browser to https://{hostname}:8443/ (admin/changeme)
* Head on to <<Walkthrough>> section.


=== Vagrant

If you don't have an Ubuntu machine then using Vagrant is an excellent option to test Celestial quickly (make sure to have link:http://opskeleton.github.io/opskeleton/latest/#installation[opskeleton] perquisites installed):

```bash
$ git clone git://github.com/opskeleton/celestial-sandbox.git
$ ./boot.sh
```

Once its done running you have a celestial instance ready and running now:

* Point your browser to https://{hostname}:8443/ (admin/changeme)
* Head on to <<Walkthrough>> section.



== Walkthrough

In this section we will setup AWS integration and create a Redis based machine, we use AWS mainly because its a publicly available API that any one can play with see <<Hypervisors>> for other supported options.

Note that if you didn't install Celestial yet then head on to [installation](/posts/installation.html) first.

Edit the hypervisor section and add the following to /etc/celestial/celestial.edn:

```clojure
:hypervisor {
  :dev {
    :aws {
	:access-key ""
	:secret-key ""
      :ostemplates {           
        :ubuntu-13.04 {:ami "ami-02b55375" :flavor :debian} 
      }
    }
  }
 } 
```

Now we will generate an ssh key on the Celestial machine, this key will be used by Celestial to access the machine via ssh:

```bash
$ ssh-keygen 
```

Configure the private key in /etc/celestial/celestial.edn (match the user to your machine):

```bash
:ssh {
  :private-key-path "/home/{user}/.ssh/id_rsa"
} 
```

Import this key into the list of keypairs in AWS (under the key pairs section) and name it celestial-demo.


We will now use the Web UI to create our first Redis based system hosted on AWS:

*   First we will add a Redis type by heading to Types > Add a Type (or https://{hostname}:8443/#/type/add/), login using admin/changeme).
*   Note that the source url is http://dl.bintray.com/content/narkisr/boxes/redis-sandbox-0.3.5.tar.gz
*   Fill up the rest of the values as in the following image:

image:walkthrough/redis-type-add.png[Linux,85%,85%]


Now head on to Systems > Add a System (or https://{hostname}:8443/#/system/add/) and add a new system (omitted values can be left empty):

image:walkthrough/system-add.png[Part1,85%,85%]

Rest of the form:

image:walkthrough/system-add-cont.png[Part2,85%,85%]

=== Launching the instance

Notice that we didn't choose an operation to be done on system save on the last screen (just for the sake of reviewing functionlity), so we will do it using operations menu. Select the stage operation from the menu:

image:walkthrough/stage-launch.png[Launch,85%,85%]

Once the job has been launched you can follow its status by heading to https://{hostname}:8443/#/jobs:

image:walkthrough/job-running.png[Running,85%,85%]


A successful job will result with:

image:walkthrough/job-done-success.png[Running,85%,85%]

You can also review the run progress in the log file (/var/log/celestial.log), you can ssh into the instance and see Redis is running (using the key you provided).

=== Where to go next

Celestial integrated with many other tools and components, you can set it up to:

*   Start to manage other hypervisors <<Proxmox>> , <<Openstack>>, <<Docker>>.
*   Register hosts atomically in DNS using link:http://www.thekelleys.org.uk/dnsmasq/doc.html[dnsmasq] <<hooks>>.
*   Publish Celestial logs into a central logging system (graylog2/kibana) for auditing the history of your infrastructure changes and track logical workflow <<Transactions>>.
*   Give access to other users and group within your organization to automatically provisioned machines, you can set quotas and limit which environment each user can access.
*   Use the Restful API and automate nightly build machines, use the Swagger UI to move quickly and learn what can be done.

## Configuration

### Overview

Celestial integrates with Hypervisors, provisioning and central logging systems, all the configuration data is kept under **/etc/celestial/celesitlial.edn** using The link:https://github.com/edn-format/edn[EDN] file format (Clojure's native data representation).

The configuration file is divided to the following sections:

*   Celestial properties like: ports, log settings and cert credentials.
*   Hypervisors where AWS, Openstack , Proxmox properties are set in matching sections.
*   Redis settings
*   SSH settings, mainly the private key path used to connect to remote instances.
*   Hooks, where we can set actions to be invoked post machine creation etc..

**See the <<Openstack>>, <<Proxmox>> and <<AWS>> sections for specific hypervisor configuration options.**

### Celestial

The Celestial section (situated on top) contains the configuration options of the Celestial server itself:
```clojure
{
 :celestial {
   :port 8082 
   :https-port 8443
   :log {
     :level :info
     :path "celestial.log"
     :gelf {
	 :host "192.168.1.1"
	 :type :kibana 
	}
   }

   :cert {
     :keystore "foo.keystore"
     :password "foobar"
   }

   :job {
     :status-expiry 5
      :lock {
        :expiry 30
        :wait-time 5
      }
   }

   ; disabled by default
   :nrepl {
     :port 7888
   }
 }
} 
```

[options="header"]
.Mandatory Settings
|===
|Section|Property|Description|Comments

.2+| ports
| port
| Standard http port
| Used for non secured anonymous operations only

| https-port
| Secured https port
| Used for secured RESTful API operations

.2+| log
| level
| Default logging level
| Optional values include: trace, debug, info, error.

| path
| Where the log file is store locally
| Recommend value for production is /var/log/celestial.log

.2+| cert
| keystore
| Java keystore file
| If no file found a file is generated with default password.

| password
| Keystore password
| This password will be used to generate a default keystore or to use an existing one.
|===


[options="header"]
.Optional Settings
|===
|Section|Property|Description|Comments

.2+| gelf
| host
| Host url of a link:https://www.graylog.org/resources/gelf/[GELF] enabled log server
|

| type
| Type of central logging either :kibana :graylog2 :logstash)
| See <<Integration>> on how to incorporate celestial with link:http://www.elasticsearch.org/overview/kibana/[kibana3].

| nrepl
| port
| Remote https://github.com/clojure/tools.nrepl[nrepl] connection for debugging, run only within a secure tunnel, emitting this settings will cause it to be disabled.
| Connecting remotely is possible using lein repl :connect host:port

.3+| job
| lock expiry
| The max time (in minutes) that a lock will be held for a job (on a system) beyond this threshold the job is considered as failed (lock is released).
| 5 minutes by default.

| lock wait-time
| The max time (in minutes) that a job will wait in order to obtain a lock on a system before giving up and failing.
| 5 minutes by default.

| status-expiry
| How long the finished jos will be kept.
| 5 minutes by default.

|===

=== Hooks

Celestial supports the notion of running hook functions after operation failure and success, one use case is registering hostnames in a link:http://www.thekelleys.org.uk/dnsmasq/doc.html[dnsmasq] server instance, notifying external systems is another. A Hook gets notified with an event stating the workflow that lead to it and its status, for an implementation hook example please see this link:https://github.com/celestial-ops/celestial-core/blob/master/src/hooks/dnsmasq.clj[example].


Hooks can be enabled by declaring them in celestial.edn, the statement includes the hooks ns followed by the called function, arguments declared within it will be passed to the function call as well.

```clojure
{
 ; rest omitted
 :hooks {
   hooks.dnsmasq/update-dns {
    :dnsmasq "192.168.1.1" :user "name" :domain "local"
 }
}
```

== Hypervisors

=== AWS


Celestial supports Amazon AWS EC2 machines (see [matrix](/posts/integration.html#aws)) in this section we will go through configuring Celestial to create AWS based systems.

AWS configuration goes under the hypervisor/aws section under the [celestial.edn](/posts/configuration.html#overview) file:

```clojure
{
  :hypervisor {
   :dev {
     :aws {
       :access-key ""
       :secret-key ""
       :ostemplates {
         :ubuntu-12.04 {:ami "" :flavor :debian}
         :centos-6 {:ami "" :flavor :redhat}
       }
      }
    }
  }
}
```

[options="header"]
.AWS configuration
|===
| Property | Description
| access-key | AWS access key
| secret-key | AWS API secret key
| ostemplates | Mappings between system os key to AMI and flavor (redhat or debian).
|===


An AWS based system has the following form (see <<Model>>):

```clojure
{
  :env :dev
  :owner "username"

  :machine {
    :hostname "red1" :user "ubuntu"
    :domain "local" :os :ubuntu-12.10
  }

  :aws {
    :instance-type "t1.micro" 
    :key-name "celestial" 
    :endpoint "ec2.eu-west-1.amazonaws.com"
  }

  :type "redis"
} 
```

|===
|Section|Property|Description|Comments
| aws | instance-type | EC2 instance type | See [docs](https://aws.amazon.com/ec2/instance-types/)

| key-name
| The EC2 machine key pair name.
| This key should match the default local machine SSH key pair that is used to SSH into the remote machines (usually ~/.ssh/id_rsa).
|
| endpoint
| The AWS endpoint that will receive request to setup this machine.
| See [endpoint list](http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region)
|
.4+| machine
| os
| Key value of mapped AWS AMI
| See [configuration](#configuration) on how to set this up

| user
| The AMI user name
| In Ubuntu based AMI this is usually set as ubuntu

| hostname
| Instance hostname
| The hostname and domain will be set on the remote machine

| domain
| Instance domain

|===



=== Docker

=== Proxmox

=== Openstack

=== Compatibility Matrix
